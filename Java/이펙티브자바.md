## 2장. 객체 생성과 파괴
### ITEM 1 : 생성자 대신 정적 팩터리 메서드를 고려하라
### ITEM 2 : 생성자에 매개변수가 많다면 빌더를 고려하라
### ITEM 3 : Private  생성자나 여거 타입으로 싱글턴임을 보증하라
### ITEM 4 : 인스턴스화를 막으려거든 private 생성자를 사용하라
### ITEM 5 : 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
### ITEM 6 : 불필요한 객체 생성을 피하라
### ITEM 7 : 다 쓴 객체 참조를 해제하라
### ITEM 8 : finalizer와 cleaner 사용을 피하라
### ITEM 9 : try-finally보다는 try-with-resources를 사용하라
## 3. 모든 객체의 공통 메서드
### ITEM 10 : equals는 일반 규약을 지켜 재정의하라
```equals``` 메서드는 곳곳에 함정이 도사리고 있어 아래 상황 중 하나에 해당된다면 재정의 하지 않는 것이 좋다.


**1. 각 인스턴스가 본질적으로 고유한 경우**
    ```Thread```와 같이 갑을 표현하는 것이 아닌, 동작하는 개체를 표현한 클래스가 여기 해당된다.
**2. 인스턴스의 '논리적 동치성(logical equality)을 검사할 일이 없는 경우**
    논리적 동치성의 검사를 원하지 않거나 필요로 하지 않는 경우 ```Object```에서 제공하는 기본 ```equals```로 해결 가능하다.
**3. 상위 클래스에서 재정의한 ```equals```가 하위 클래스에도 딱 들어맞는 경우**
    예를 들어 대부분의 ```Set``` 구현체는 ```AbstractSet``` 이 구현한 ```equals```를 상속받아 그대로 쓴다.
**4. 클래스가 private이거나 package-private이고 ```equals``` 메서드를 호출할 일이 없는 경우**
    ```equals``` 메서드의 호출을 강제하고 싶다면 아래와 같이 구현하는 방법이 있다.
```java
@Override
public boolean equals(Object o) {
    throw new AssrtionError();
}
```

결론적으로, 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 ```equals```가 논리적 동치성을 비교하도록 재정의되지 않았을 때 ```equals``` 메서드를 재정의 해야한다. 

```equals``` 메서드는 동치관계를 구현하며 **반사성**, **대칭성**, **추이성**, **일관성**, **null-아님** 속성을 만족해야 한다.

**반사성**의 경우 단순히 말해 자기 자신과 같아야 한다는 뜻이다. 


**대칭성**은 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다는 뜻이다.
```java
x.equals(y)
y.equals(x) // 1이 ture면 2도 true여야 한다.
```
대소문자를 무사하는 클래스 ```CaseInsensitiveString``` 클래스를 고려해보자.
```java
public final class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString)
            return s.equalsIgnoreCase((CaseInsensitiveString o).s);
        if (o instanceof String)
            return s.equalsIgnoreCase((String) o);
        return false;
    }
    ...
}
```

위 클래스의 ```equals``` 메서드는 일반 문자열과도 비교를 시도한다.
```java
CaseInsensitiveString cis = new CaseInsensitiveString("Hello");
String s = "hello";
```
위 예시의 경우 ```cis.equals(s)```는 **true**를 반환한다.  
하지만  ```s.equals(cin)```의 경우 일반 문자열은 ```CaseInsensitiveString```의 존재 여부를 모르기 때문에 **false**를 반환하며, 이는 명백히 대칭성의 위반이다.

이 문제를 해결하기 위해 ```CaseInsensitiveString```와 일반 문자열을 연동하겠다는 허황된 꿈을 버려야 하며, 그 결과 아래와 같이 간단한 모습으로 바뀐다.
```java
@Override
public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString && 
    ((CaseInsensitiveSTring) o).s.equalsIgnoreCase(s);
}
```
**추이성**은 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫번쨰 객체와 세 번째 객체도 같아야 한다는 뜻이다.  
하위 클래스에서 상위 클래스와 비교하는 경우 하위 클래스의 핵심 필드를 무시하는 경우 추이성이 위반될 수 있다.
```java
ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
```
이 경우 ```p1.equals(p2)```와 ```p2.equals(p3)```는 **true**를 반환하지만 ```p1.equals(p3)```는 **false*를 반환하게 된다. 

구체 클래스를 확장해 새로운 값을 추가하면서 ```equals```구약을 만족시킬 방법은 존재하지 않는다. 

**일관성**은 두 객체가 같다면 (수정되지 않는 한) 앞으로도 영원히 같아야 한다는 뜻이다.  
클래스가 불변이든 가변이든 ```equals```의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다. 예를 들어 ```java.net.URL```의 경우 주어진 URL과 매핑된 호스트의 IP 주소를 이용해 비교한다. 호스트 이름을 IP 주소로 바꾸려면 네트워크를 통해야 하며, 그 결과가 항상 같다고 보장할 수 없다.  
이런 문제를 피하려면 ```equals```는 항시 메모리에 존재하는 객체만을 사용한 결정적 계산만 수행해야 한다.

**null-아님**은 이름과 같이 모든 객체가 ```null```과 같지 않아야 한다는 뜻이다.

위 내용을 종합하여 작성한 양질의 ```equals``` 메서드는 아래와 같다.
```java
@Override
public boolean equals(Object o) {
    if(o == this)
        return true;
    if(!(o instanceof PhoneNumber))
        return false;
    PhoneNumber pn = (PhoneNumber) o;
    return pn.lineNum == lineNum && pn.prefix == prefix;
}
```
### ITEM 11 : equals를 재정의하려거든 hashCode도 재정의하라
```HashCode``` 일반 규약에 의하면 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다. 해당 규약을 어기게 된다면 ```HashMap```을 사용할 시 값을 못 찾는 등의 문제가 발생할 수 있다. (논리적으론 같은 인스턴스지만, 해쉬값이 다름으로)  
이 문제는 적절한 ```HashCode``` 메서드를 작성해주면 해결할 수 있다.

```java
@Override
public int hashCode() {
    return 318;
}
```
이 코드는 동치인 모든 객체에 대해 같은 해시코드를 반환하니 적법하다. 하지만 모든 객체에게 똑같은 값만 반환함으로 해시테이블이 매우 비 효율적으로 작동한다.
(평균 작동시간이```O(1)```인 해시테이블이 링크드 리스트와 같이 ```O(n)```으로 작동)

좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다.
```java
@Override
public int hashCode() {
    int result = Integer.hashCode(field1);
    int result = 31 * result + Integer.hashCode(field2);
    int result = 31 * result + Integer.hashCode(field3);
    return result;
}
// 전형적인 hashCode 메서드. 31을 곱하는 이유는 홀수이면서 소수이기 때문.
```

성능에 민감하지 않은 경우라면 ```Objects```의 ```hash``` 메서드를 활용할 수 있다.
```java
@Override
public int hashCode() {
    return Objects.hash(field1, field2, field3);
}

```

클래스가 불변하는 경우 해시코드를 매번 개산하기 보다, 캐싱하는 방식을 고려할 수 있다.
```java
private int hashCode;

@Override
public int hashCode() {
    int result = hashCode;
    if(result == 0) { // 지연 초기화
        int result = Integer.hashCode(field1);
        int result = 31 * result + Integer.hashCode(field2);
        int result = 31 * result + Integer.hashCode(field3);
        hashCode = result;
    }
    return result;
}
```